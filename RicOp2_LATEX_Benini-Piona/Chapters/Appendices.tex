% !TEX TS-program = pdflatex
% !TEX root = ../ArsClassica.tex

%************************************************
\begin{appendices}
%************************************************
\chapter{CPLEX}
Questo l'ho messo solo perchè nella tesina dei tuoi amici c'è un'appendice su CPLEX .. dacci un occhio e decidiamo se vogliamo qualcosa di simile o no.

\chapter{Shell script}
The collection of the results is an important part of our software development. Gives us the possibility to run the same code on different instances, to collect the results in a accessible way, to compare results obtained with different CPLEX parameters and finally gives us the convenience to store all the result of a run in the same folder. 
For those reasons when we were still at the beginning of the development we create a shell script that automates the process. It is composed by some parts:
\begin{enumerate}
\item Make: compiles the code at the actual state.
\item Creates the plot folder and the results folder named with the actual timestamp.
\item Defines the the command line parameter in the \textit{settings} variable.
\item Starts a cycle iterating over all the .turb files in the data folder, that represent all the instances. For each iteration it executes the wfcp script and saves the logs in the right folder giving them a name that associate it to the instance. The \textit{cSub} variable is set in order to use the correct $C$ for each instance.
\item Order some files, also the .png results if present.
\item Creates the settings.txt file with the execution settings of that run.
\item Creates the results.csv file that collects all the instances results coming from the logs.
\end{enumerate}

The script detects the working directory from which the script is launched so it is adaptable to different environment if the folder structure is the following:
\begin{itemize}
\item main directory
\item data: contains all the .turb and .cbl file
\item runs: contains the results 
\item src: contains the script files and the multi\_wfcp.sh file. 
\end{itemize}

Here the code of the \textit{multi\_wfcp.sh} file:
\newpage
\lstinputlisting[language=bash,caption={Shell multi\_wfcp.sh script}]{/home/davide/dev/WFCP/src/multi_wfcp.sh}

\chapter{Input string parameteres}
In our code we tried to parameterize all the compilation options, in order to avoid to change the code for little changes or different tests. \\
Here we describe all the parameter in a ready-to-use list of options: 
\begin{itemize}
\setlength{\parskip}{0pt}
\setlength{\itemsep}{0.5pt plus 1pt}
\item \textbf{fc} : input cables file
\item \textbf{ft} : input turbines file
\item \textbf{C} : capacity of root
\item \textbf{time\_loop} : time for loop in loop/heuristic method
\item \textbf{time\_limit} : total time limit
\item \textbf{time\_start} : time start to heuristic method
\item \textbf{model} : model type
\begin{enumerate}\setcounter{enumi}{-1}
\setlength{\parskip}{0pt}
\setlength{\itemsep}{0pt plus 1pt}
	\item Cplex model
	\item Matrix model
\end{enumerate}
\item \textbf{rins} : rins
\item \textbf{relax} : relax
\begin{enumerate}\setcounter{enumi}{0}
\setlength{\parskip}{0pt}
\setlength{\itemsep}{0pt plus 1pt}
	\item relax on station capacity
	\item relax on flux
	\item relax on flux + out edges
	\item[] else : no relax
\end{enumerate}
\item \textbf{polishing\_time} : polishing time
\item \textbf{gap} : gap to terminate
\item \textbf{seed} : random seed
\item \textbf{threads} : n threads
\item \textbf{CC} : Cross Constraints
\begin{enumerate}\setcounter{enumi}{-1}
\setlength{\parskip}{0pt}
\setlength{\itemsep}{0pt plus 1pt}
	\item Normal execution with no cross cable as normal constraints
	\item Lazy constraints to the model
	\item loop Method
	\item Normal execution + lazy callback
	\item Hard Fixing
	\item Soft Fixing
	\item Heuristic
	\item Heuristic Loop to have multiple solution
	\item Heuristic with 1-opt
	\item Tabu Search
	\item Multi-start
	\item[] else: Normal Execution
\end{enumerate}
\item \textbf{soft\_fix} : Type of soft fixing
\begin{enumerate}\setcounter{enumi}{0}
\setlength{\parskip}{0pt}
\setlength{\itemsep}{0pt plus 1pt}
	\item Asimmetric Local Branching
	\item Simmetric Local Branching
	\item Asimmetric RINS
	\item Simmetric RINS
\end{enumerate}
\item \textbf{hard\_fix} : Type of hard fixing
\begin{enumerate}\setcounter{enumi}{0}
\setlength{\parskip}{0pt}
\setlength{\itemsep}{0pt plus 1pt}
	\item Random hard fixing
	\item RINS
\end{enumerate}
\item \textbf{times} : times to do heuristic
\item \textbf{names} : 1 for more clear file names
\end{itemize}

\chapter{Performance Profile}
un'altra appendice che potremmo mettere è quella su gnuplot .. noi l'abbiamo utilizzato in qualche modo particolare rispetto ad altri gruppi o abbiamo fatto come tutti? 

\chapter{Performance Variability and Random Seed}
The performance of MIP solvers is subject to some variability that appears when changing from different computing platforms.The literature case \cite{danna2008performance}, shows us that it could happen that the same instance, with the same code is solved at the root node in one platform, and requires 1426 nodes in another. It is even possible to have different results even if we’re comparing two runs in different partition of the same machine. According to \cite{lodi2013performance} also the permutation of rows and/or columns of a model could lead to different performance. The performance variability is common for all the different MIP solvers. 
The reason of that, in a simplified view, is that the small differences of precision between different environment can lead to different branching variables. Infact the Branch and Bound approach is defined “chaotic” because little variations lead to big changes. \\
In literature there are some approaches to this problem and also exploiting this situation for better overall solver performance: developing pseudo-cost formulas that selects the branching variables in a more robust way or to try some different basis and evaluate which is the best alternative (this solution adds a computational overhead). \\
Also CPLEX offers a possible solution giving the random seed parameter that can be used to change the initialization of the random number generator that is used in some internal operations, with the purpose also to speed up the computation. The random seed  enforces the random variability giving the possibility to collect statistics of N different runs for more comparable results. \\
For the purpose of our research the performance variability is not a central question, however it is important for two reasons. First, to understand that the same code applied to the same instance can lead to different solution paths depending on the environments. Second, because a variability means that it is possible to take different choices, that means there’s a way to choose better and improve again the performances. 














%************************************************
\end{appendices}



